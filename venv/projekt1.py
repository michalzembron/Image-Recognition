# -*- coding: utf-8 -*-
"""Projekt1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14ADLb--hLIJd8dTVZxp2yGZ1QcKFIXxG
"""

#Wstepna konfiguracja
!pip install read_roi

from read_roi import read_roi_zip
from PIL import Image
import numpy as np
from matplotlib.path import Path
import cv2
import matplotlib.pyplot as plt
from google.colab import drive

import glob

drive.mount('/content/drive')

#Wczytywanie obrazu i pliku ROI

#Wczytywanie wszystkich plików z folderu
allTifs = glob.glob("drive/My Drive/Colab Notebooks/Projekt/ROIS/*.tif")
allRois = glob.glob("drive/My Drive/Colab Notebooks/Projekt/ROIS/*.zip")

print(allTifs)
print(allRois)

#Utworzenie maski z pliku ROI

def erozja(maska):
  #Pierwsza erozja maski przy użyciu elementu [[1,1,1],[1,1,1],[1,1,1]]
  kernel_one = np.ones((3,3),np.uint8)
  firstErosionImage = cv2.erode(maska,kernel_one)
  #Druga erozja maski przy użyciu elementu [[0,1,0],[1,1,1],[0,1,0]]
  kernel_two = np.array([[0,1,0], [1,1,1], [0,1,0]], np.uint8)
  secondErosionImage = cv2.erode(firstErosionImage,kernel_two)
  #Odjęcie od pierwotnej maski nowej zerodowanej maski w celu utworzenia pierwszej części krawędzi jądra oraz wnętrza jądra komórkowego
  nucleus_border = maska - secondErosionImage
  return nucleus_border

def dylatacja(maska):
  #Pojedyncza dylatacja maski pierwotnej 
  kernel_one = np.ones((3,3),np.uint8)
  dilation = cv2.dilate(maska,kernel_one,iterations = 2)
  #Odjęcie nowej maski od maski pierwotnej w celu uzyskania drugiej części krawędzi jądra komórkowego
  dilation_border = maska - dilation
  #Usuwanie kolorów pośrednich, żeby elementy były tylko czarne lub białe
  dilation_border[dilation_border >= 250] = 255
  dilation_border[dilation_border < 250] = 0
  return dilation_border

def sumowanieKrawedzi(wynikErozji, wynikDylatacji):
  borders = wynikErozji + wynikDylatacji
  return borders

def tworzenieMaski(ROIS, im, nazwaPliku):
  im = Image.open(im)
  ROIS = read_roi_zip(ROIS)
  #print(len(ROIS))
  w, h = im.size
  maskSum = 0
  sumaKrawedzi = 0
  iteracja = 0

  krawedz = 0
  wnetrze = 0
  image = 0
  images = np.zeros((h,w))
  for k in ROIS.values():
    x = k.get('x')
    y = k.get('y')
    #liczba współrzędnych k-tego ROI
    n = len(x)
    #generowanie współrzędnych poligonu
    i = 0
    ListOfCorners = []
    for i in range(i,n):
      ListOfCorners.append((int((y[i])), int((x[i]))))
    #generowanie masek poligonów
    poly_path = Path(ListOfCorners)
    Nx, Ny = np.mgrid[:h, :w]
    coordinates = np.hstack((Nx.reshape(-1, 1), Ny.reshape(-1, 1)))
    mask = poly_path.contains_points(coordinates)
    mask = mask.reshape(h, w)
    mask = np.array(mask, dtype=bool)
    mask = 255 * mask
    mask = np.array(mask, dtype='uint8')

    er = erozja(mask)
    dy = dylatacja(mask)
    krawedz = sumowanieKrawedzi(er,dy)
    wnetrze = mask - er
    wnetrze[wnetrze == 255] = 2
    krawedz[krawedz == 255] = 1
    image = wnetrze + krawedz
    imageMask = (image != 0)
    images[imageMask] = image[imageMask]

    print("\rPostęp: " + str(round(((iteracja+1.0) / len(ROIS)) * 100, 1)), end="%")
    iteracja += 1
  print("\nUkończono przetwarzanie maski, tworzę etykiety i zapisuję do pliku:\n" + "drive/My Drive/Colab Notebooks/Projekt/ROIS/" + nazwaPliku + "_labels.png\n")
  ImageEtykiety = Image.fromarray(np.uint8(images))
  ImageEtykiety.save('drive/My Drive/Colab Notebooks/Projekt/ROIS/' + nazwaPliku + '_labels.png')
  #print(np.unique(images))
  fig = plt.figure()
  fig.set_size_inches(10, 10)
  ax1 = fig.add_subplot(1,1,1)
  ax1.imshow(images*127, cmap='gray')
  ax1.set_title("MASKA")

if (len(allTifs) == len(allRois)):
  print("Ilość plików .tif jest równa ilości plików ROI w .zip.")
  for wybranyPlik in range(len(allRois)):
    print("Obecnie przetwarzam: " + allRois[wybranyPlik])
    nazwaPliku = allRois[wybranyPlik].split('ROIS/')[1]
    nazwaPliku = nazwaPliku.split('.zip')[0]
    tworzenieMaski(allRois[wybranyPlik], allTifs[wybranyPlik], nazwaPliku)
else:
  print("BŁĄD ! Ilość plików .tif NIE jest równa ilości plików ROI w .zip.")